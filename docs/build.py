#!/usr/bin/env python3

# ****************************************************************************
# IMPORTANT: If you are getting a lexer error for an example you need to check
#            for extra lines at the end of the file. Only a single empty line
#            is allowed!!! Ask me how long it took me to figure this out
# ****************************************************************************


def run():
    import sys
    import os
    import subprocess
    import re
    import example_list as ex
    import doc_builder
    import shutil
    import tempfile
    import config_builder
    import add_translation
    from argparse import ArgumentParser
    import breathe.project

    def ProjectInfoFactory__init__(self, app):
        self.app = app

        self._default_build_dir = os.fspath(
            os.path.dirname(app.doctreedir.rstrip(os.sep))
            )
        self.project_count = 0
        self.project_info_store = {}
        self.project_info_for_auto_store = {}
        self.auto_project_info_store = {}

    setattr(breathe.project.ProjectInfoFactory, '__init__',  ProjectInfoFactory__init__)

    # this class wrapps stdout and stderr so we can collect warnings
    # and errors generated by sphinx and doxygen. This way we are able to raise
    # an exception and fail the build.
    class STDWrapper(object):

        def __init__(self, std):
            self.enabled = False
            self._std = std
            self.errors = []

        def write(self, d):
            if (
                self.enabled and
                ('ERROR' in d or 'WARNING' in d or 'traceback' in d) and
                'Found multiple matches for file "lvgl.h' not in d
            ):
                self.errors.append(d)

            self._std.write(d)

        def __getattr__(self, item):
            if item in self.__dict__:
                return self.__dict__[item]

            return getattr(self._std, item)

    stdout = sys.stdout = STDWrapper(sys.stdout)
    stderr = sys.stdout = STDWrapper(sys.stderr)

    from sphinx.cmd.build import main as sphinx_build

    base_path = os.path.abspath(os.path.dirname(__file__))
    project_path = os.path.abspath(os.path.join(base_path, '..'))

    temp_path = tempfile.mkdtemp(suffix='.lvgl_docs')

    arg_parser = ArgumentParser(prefix_chars='boidlc')
    arg_parser.add_argument(
        'clean',
        dest='clean',
        default=False,
        action='store_true'
    )

    arg_parser.add_argument(
        'latex',
        dest='latex',
        default=False,
        action='store_true'
    )

    arg_parser.add_argument(
        'develop',
        dest='develop',
        default=False,
        action='store_true'
    )

    arg_parser.add_argument(
        'ignore-missing-warnings',
        dest='ignore_missing_warnings',
        default=False,
        action='store_true'
    )

    arg_parser.add_argument(
        'build-path',
        dest='build_path',
        default=temp_path,
        type=str,
        action='store'
    )

    arg_parser.add_argument(
        'output-path',
        dest='output_path',
        default=os.path.join(project_path, 'out_html'),
        type=str,
        action='store'
    )

    args = arg_parser.parse_args()

    clean = args.clean
    skip_latex = not args.latex
    develop = args.develop

    doc_builder.EMIT_WARNINGS = not args.ignore_missing_warnings

    # due to the modifications that take place to the documentation files
    # when the documentation builds it is better to copy the source files to a
    # temporary folder and modify the copies. Not setting it up this way makes
    # it a real headache when making alterations that need to be committed as
    # the alterations trigger the files as changed.

    # If there is debugging that needs to be done you can provide a command line
    # switch of "develop" and it will leave the temporary directory in tact and
    # that directory will be output at the end of the build.

    # the html and PDF output locations are going to remain the same as they
    # were. it's just the source documentation files that are going to be
    # copied.

    temp_directory = args.build_path
    examples_path = os.path.join(project_path, 'examples')
    lvgl_src_path = os.path.join(project_path, 'src')
    latex_output_path = os.path.join(temp_directory, 'out_latex')
    pdf_src_file = os.path.join(latex_output_path, 'LVGL.pdf')
    pdf_dst_file = os.path.join(temp_directory, 'LVGL.pdf')
    html_src_path = temp_directory
    html_dst_path = args.output_path

    lvgl_header_path = os.path.join(project_path, 'lvgl.h')
    lv_config_path = os.path.join(base_path, 'lv_conf.h')

    os.chdir(base_path)

    if temp_path != temp_directory:
        if not os.path.exists(temp_directory):
            os.makedirs(temp_directory)
            temp_path_exists = False
        else:
            temp_path_exists = True

        shutil.rmtree(temp_path)
    else:
        temp_path_exists = False

    def cmd(s):
        print('running command: ', s)

        result = os.system(s)
        if result != 0:
            print("Exit build due to previous error")
            sys.exit(result)

    # Get the current branch name
    status, br = subprocess.getstatusoutput("git branch --show-current")
    _, gitcommit = subprocess.getstatusoutput("git rev-parse HEAD")
    br = re.sub('\* ', '', br)  # NOQA

    urlpath = re.sub('release/', '', br)

    os.environ['LVGL_URLPATH'] = urlpath
    os.environ['LVGL_GITCOMMIT'] = gitcommit

    if clean:
        print('cleaning...')
        if os.path.exists(html_dst_path):
            shutil.rmtree(html_dst_path)

        if temp_path_exists:
            try:
                shutil.rmtree(temp_directory)
                os.mkdir(temp_directory)
            except OSError:
                raise RuntimeError(
                    f'Unable to clean build path "{temp_directory}"'
                )

    print('generating lv_conf.h file...')
    config_builder.run()
    print('copying documentation files to build directory...')
    shutil.copytree('.', temp_directory, dirs_exist_ok=True)
    print('copying examkples to build directory...')
    shutil.copytree(examples_path, os.path.join(temp_directory, 'examples'))

    def iter_rst_files(p):
        for file in os.listdir(p):
            file = os.path.join(p, file)
            if os.path.isdir(file):
                iter_rst_files(file)
            elif file.endswith('.rst'):
                with open(file, 'rb') as fle:
                    dta = fle.read().decode('utf-8')

                if '../../examples' in dta:
                    dta = dta.replace(
                        '../../examples',
                        '../examples'
                    )
                    with open(file, 'wb') as fle:
                        fle.write(dta.encode('utf-8'))

    iter_rst_files(temp_directory)

    print('generating goxygen config file...')

    with open(os.path.join(temp_directory, 'Doxyfile'), 'rb') as f:
        data = f.read().decode('utf-8')

    demo_header = os.path.join(project_path, 'demos', 'lv_demos.h')

    data = data.replace(
        '*#*#SRC#*#*',
        f'"{base_path}" "{lv_config_path}" "{lvgl_header_path}" "{demo_header}" "{project_path}"'
    )

    src_lvgl_header = os.path.join(project_path, 'src', 'lvgl.h')

    data = data.replace(
        '*#*#EXCLUDE#*#*',
        f'"{src_lvgl_header}"'
    )

    with open(os.path.join(temp_directory, 'Doxyfile'), 'wb') as f:
        f.write(data.encode('utf-8'))

    #
    # with open(os.path.join(temp_directory, 'conf.py'), 'rb') as f:
    #     data = f.read().decode('utf-8')
    #
    # data = data.replace(
    #     '#*#*LV_CONF_PATH*#*#',
    #     os.path.join(base_path, 'lv_conf.h')
    # )
    # data = data.replace('#*#*PROJECT_PATH*#*#', project_path)
    #
    # with open(os.path.join(temp_directory, 'conf.py'), 'wb') as f:
    #     f.write(data.encode('utf-8'))

    print("generating examples...")
    ex.exec(temp_directory)

    print("adding translation...")
    add_translation.exec(temp_directory)

    print("running doxygen...")

    stdout.enabled = True
    stderr.enabled = True

    cmd(f'cd "{temp_directory}" && doxygen Doxyfile')

    print('parsing doxygen xml files...')

    stdout.enabled = False
    stderr.enabled = False

    doc_builder.run(
        project_path,
        temp_directory,
        os.path.join(temp_directory, 'layouts'),
        os.path.join(temp_directory, 'libs'),
        os.path.join(temp_directory, 'others'),
        os.path.join(temp_directory, 'overview'),
        os.path.join(temp_directory, 'overview', 'renderers'),
        os.path.join(temp_directory, 'porting'),
        os.path.join(temp_directory, 'widgets')
    )

    # we make sure to remove the link to the PDF before the PDF get generated
    # doesn't make any sense to have a link to the PDF in the PDF. The link gets
    # added if there is a PDF build so the HTML build will have the link.
    index_path = os.path.join(temp_directory, 'index.rst')

    with open(index_path, 'rb') as f:
        index_data = f.read().decode('utf-8')

    if 'PDF version: :download:`LVGL.pdf <LVGL.pdf>`' in index_data:
        index_data = index_data.replace(
            'PDF version: :download:`LVGL.pdf <LVGL.pdf>`\n',
            ''
        )
        with open(index_path, 'wb') as f:
            f.write(index_data.encode('utf-8'))

    # BUILD PDF
    if not skip_latex:
        # Silly workaround to include the more or less correct
        # PDF download link in the PDF

        sphinx_args = [
            '-b',
            'latex',
            temp_directory,
            latex_output_path,
            '--fail-on-warning',
            '--keep-going',
            '-j',
            f'{os.cpu_count()}'
        ]

        print('running sphinx to build latex files...')

        sphinx_build(sphinx_args)

        # Generate PDF
        cmd(f'cd "{latex_output_path}" && latexmk -pdf "LVGL.tex"')

        # Copy the result PDF to the main directory to make
        # it available for the HTML build
        shutil.copyfile(pdf_src_file, pdf_dst_file)

        # cmd("cd out_latex && cp -f LVGL.pdf ../LVGL.pdf")

        # add the PDF link so the HTML build will have it.
        index_data = (
            f'PDF version: :download:`LVGL.pdf <LVGL.pdf>`\n{index_data}'
        )

        with open(index_path, 'wb') as f:
            f.write(index_data.encode('utf-8'))

    def get_version():
        path = os.path.join(project_path, 'lv_version.h')
        with open(path, 'rb') as fle:
            d = fle.read().decode('utf-8')

        d = d.split('#define LVGL_VERSION_MAJOR', 1)[-1]
        major, d = d.split('\n', 1)
        d = d.split('#define LVGL_VERSION_MINOR', 1)[-1]
        minor, d = d.split('\n', 1)

        # d = d.split('#define LVGL_VERSION_PATCH', 1)[-1]
        # patch, d = d.split('\n', 1)

        return f'{major.strip()}.{minor.strip()}'

    # I am not a big fan of runing subprocesses to run sphinx.
    # Now we can run it directly without any issues.
    sphinx_args = [
        '-b',
        'html',
        html_src_path,
        html_dst_path,
        '-D',
        f'version="{get_version()}"',
        '--fail-on-warning',
        '--keep-going',
        '-E',
        '-j',
        f'{os.cpu_count()}'
    ]

    print('running sphinx to build html files...')
    sphinx_build(sphinx_args)

    if stdout.errors:
        print('\n\n'.join(stdout.errors))
    if stderr.errors:
        print('\n\n'.join(stderr.errors))

    if develop:
        print('temp directory:', temp_directory)
    else:
        if not temp_path_exists:
            try:
                shutil.rmtree(temp_directory)
            except OSError:
                print(
                    f'Unable to remove temporary directory "{temp_directory}"'
                )
        else:
            print('temp directory:', temp_directory)

    config_builder.cleanup()

    if stdout.errors or stderr.errors:
        raise RuntimeError

    print('output path:', html_dst_path)
    print('\nFINISHED!!')


# because sphinx can use multiple CPU cores when it compiles this requires
# launching the script multiple times from different subprocesses. We only want
# the build script to run a single time and that is when the user runs the
# script. By checking the package name of this file to see if it is the "main"
# script puts in place a block so the build script only runs a single time
# even when the script gets run from multiple processes.
if __name__ == '__main__':
    run()
